<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 15, 2018</span>
									<h1>zoopkeeper: application scene</h1>
								</header>


                <h3>zookeeper提供了什么</h3>
                <p>zookeeper=文件系统+通知机制。</p>
                <h4>1. 文件系统</h4>
                <p>Zookeeper维护一个类似文件系统的数据结构，每个子目录项，如NameService都被称作为 znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article025_001.png" alt="" />
                </div>
                <p>有四种类型的znode：</p>
                <blockquote>
                <p>
                    1、PERSISTENT-持久化目录节点，客户端与zookeeper断开连接后，该节点依旧存在<br>
                    2、 PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点，客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号<br>
                    3、EPHEMERAL-临时目录节点，客户端与zookeeper断开连接后，该节点被删除<br>
                    4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点，客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号<br>
                </p>
                </blockquote>
                <h4>2. 通知机制</h4>
                <p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变/被删除、子目录节点增加/删除）时，zookeeper会通知客户端。 </p>

                <h3>zookeeper可以做什么</h3>

                <h4>1. 命名服务(Naming Service)</h4>
                <p style="background-color: #C2C287; color: #333;font-size: 10pt;">
                命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据名字来获取资源或服务的地址、提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p>
                <p style="background-color: #D0D0D0; color: #333;font-size: 10pt;"> 阿里巴巴开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表。在Dubbo实现中：<br>
                服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。<br>
                服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。<br>
                注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。<br><br></p>

                <h4>2. 配置管理</h4>
                <p style="background-color: #C2C287; color: #333;font-size: 10pt;">
                程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。现在将应用的配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article025_002.png" alt="" />
                </div>
                <p style="background-color: #D0D0D0; color: #333;font-size: 10pt;"> 注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。<br><br></p>

                <h4>3. 集群管理与Master选举</h4>
                <p style="background-color: #C2C287; color: #333;font-size: 10pt;">
                所谓集群管理无在乎两点：是否有机器退出和加入、选举master。<br>
                对于集群管理：所有机器都在父目录GroupMembers节点上注册一个Watcher，以后每动态加机器，那么就往 /GroupMembers 下创建一个临时目录节点（EPHEMERAL）：/GroupMembers/{hostname}，然后监听父目录GroupMembers的子节点变化消息。
                一旦有机器挂掉，该机器与zookeeper的连接断开，其所创建的临时节点被删除，所有其他机器都收到通知：某个兄弟目录被删除了。新机器加入也是类似，所有机器收到通知。<br>
                对于选举master：我们稍微改变一下，所有机器创建临时顺序编号节点（EPHEMERAL_SEQUENTIAL），每次选取编号最小的机器作为master就好。<br><br>
                </p>

                <h4>4. 分布式锁</h4>
                <p style="background-color: #C2C287; color: #333;font-size: 10pt;">
                锁服务可以分为两类，一个是保持独占，另一个是控制时序。<br>
                利用ZooKeeper实现分布式lock，主要是通过一个临时顺序编号Node（EPHEMERAL_SEQUENTIAL）来代表一个Lock，当一个client去拿锁的时候，会在这个Node下创建一个自增序列的child，然后通过getChildren()方式来check创建的child是不是最靠前的，如果是则拿到锁，否则就调用exist()来check第二靠前的child，并加上watch来监视。当拿到锁的child执行完后归还锁，归还锁仅仅需要删除自己创建的child，这时watch机制会通知到所有没有拿到锁的client，这些child就会根据前面所讲的拿锁规则来竞争锁。<br><br></p>

                <h4>5. 分布式队列</h4>
                <p style="background-color: #C2C287; color: #333;font-size: 10pt;">
                ZooKeeper提供了一个种简单的方式， ZooKeeper通过一个Node来维护Queue的实体，用其children来存储Queue的内容，并且ZooKeeper的create方法中提供了顺序递增的模式，会自动地在name后面加上一个递增的数字来插入新元素。可以用其children来构建一个queue的数据结构，offer的时候使用create，take的时候按照children的顺序删除第一个即可。 ZooKeeper保障了各个server上数据是一致的，因此也就实现了一个分布式Queue。<br>
                实现类为org.apache.zookeeper.recipes.queue.DistributedQueue，其中take和offer的实例代码如下所示：</p>
                <pre>
                  <code>
/**
 * Removes the head of the queue and returns it, blocks until it succeeds.
 * @return The former head of the queue
 * @throws NoSuchElementException
 * @throws KeeperException
 * @throws InterruptedException
 */
public byte[] take() throws KeeperException, InterruptedException {
    Map&lt;Long,String&gt; orderedChildren;
    // Same as for element.  Should refactor this.
    while(true){
        LatchChildWatcher childWatcher = new LatchChildWatcher();
        try{
            orderedChildren = orderedChildren(childWatcher);
        }catch(KeeperException.NoNodeException e){
            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);
            continue;
        }
        if(orderedChildren.size() == 0){
            childWatcher.await();
            continue;
        }

        for(String headNode : orderedChildren.values()){
            String path = dir +&quot;/&quot;+headNode;
            try{
                byte[] data = zookeeper.getData(path, false, null);
                zookeeper.delete(path, -1);
                return data;
            }catch(KeeperException.NoNodeException e){
                // Another client deleted the node first.
            }
        }
    }
}

/**
 * Inserts data into queue.
 * @param data
 * @return true if data was successfully added
 */
public boolean offer(byte[] data) throws KeeperException, InterruptedException{
    for(;;){
        try{
            zookeeper.create(dir+&quot;/&quot;+prefix, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);
            return true;
        }catch(KeeperException.NoNodeException e){
            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);
        }
    }

}
                  </code>
                </pre>
        
				




               



							</section>
					</div>



				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>