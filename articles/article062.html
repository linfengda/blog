<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 15, 2018</span>
									<h1>java nio</h1>
								</header>


				<h3>传统的BIO编程：</h3>
                <p>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 可以看到，多个客户端同时向服务端发送请求服务端做出的措施是开启多个线程来匹配相对应的客户端，并且每个线程去独自完成他们的客户端请求。</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_001.png" alt="" />
                </div>

                <p>用代码演示下，1. 写一个简单的服务器（用到了线程池的技术来创建线程）：</p>
				<pre>
                  <code>
public class MyServer {
	private static ExecutorService executorService = Executors.newCachedThreadPool(); // 创建一个线程池

	private static class HandleMsg implements Runnable { // 一旦有新的客户端请求，创建这个线程进行处理
		Socket client; // 创建一个客户端

		public HandleMsg(Socket client) { // 构造传参绑定
			this.client = client;
		}

		@Override
		public void run() {
			BufferedReader bufferedReader = null; // 创建字符缓存输入流
			PrintWriter printWriter = null; // 创建字符写入流
			try {
				bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream())); // 获取客户端的输入流
				printWriter = new PrintWriter(client.getOutputStream(), true); // 获取客户端的输出流，true是随时刷新
				String inputLine = null;
				long a = System.currentTimeMillis();
				while ((inputLine = bufferedReader.readLine()) != null) {
					printWriter.println(inputLine);
				}
				long b = System.currentTimeMillis();
				System.out.println("此线程花费了：" + (b - a) + "秒！");
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				try {
					bufferedReader.close();
					printWriter.close();
					client.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public static void main(String[] args) throws IOException { // 服务端的主线程是用来循环监听客户端请求
		ServerSocket server = new ServerSocket(8686); // 创建一个服务端且端口为8686
		Socket client = null;
		while (true) { // 循环监听
			client = server.accept(); // 服务端监听到一个客户端请求
			System.out.println(client.getRemoteSocketAddress() + "地址的客户端连接成功!");
			executorService.submit(new HandleMsg(client)); // 将该客户端请求通过线程池放入HandlMsg线程中进行处理
		}
	}

}
                  </code>
                </pre>
                <p>2. 写一个简单客户端：</p>
				<pre>
                  <code>
public class MyClient {
	
	public static void main(String[] args) throws IOException {
		Socket client = null;
		PrintWriter printWriter = null;
		BufferedReader bufferedReader = null;
		try {
			client = new Socket();
			client.connect(new InetSocketAddress("localhost", 8686));
			printWriter = new PrintWriter(client.getOutputStream(), true);
			printWriter.println("hello");
			printWriter.flush();

			bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream())); // 读取服务器返回的信息并进行输出
			System.out.println("来自服务器的信息是：" + bufferedReader.readLine());
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			printWriter.close();
			bufferedReader.close();
			client.close();
		}
	}
}
                  </code>
                </pre>

                <p>3. 代码运行结果如下图</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_002.png" alt="" />
                </div>
				<p>
					如果一个客户端请求中，IO写入到服务端过程中耗时10秒，即每个请求占用服务端线程10秒<br>
					然后有大量的客户端请求，每个请求都占用那么长时间，那么服务端的并能能力就会大幅度下降<br>
					这并不是因为服务端有多少繁重的任务，而仅仅是因为服务线程在等待IO（因为accept，read，write都是阻塞式的）<br>
					让高速运行的CPU去等待及其低效的网络IO是非常不合算的行为<br><br><br>
				</p>


				<h3>NIO编程：</h3>
                <p>
					New IO成功的解决了上述问题，它是怎样解决的呢？<br>
					IO处理客户端请求的最小单位是线程，而NIO使用了比线程还小一级的单位：通道（Channel）<br>
					可以说，NIO中只需要一个线程就能完成所有接收，读，写等操作<br><br>

					要学习NIO，首先要理解它的三大核心<br>
				</p>
				<blockquote>
				<p>
					Buffer，缓冲区<br>
					Channel，通道<br>
					Selector，选择器<br>
				</p>
				</blockquote>

				<p>类关系图：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_003.png" alt="" />
                </div>
                <p>TCP下的NIO工作流程图：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_004.png" alt="" />
                </div>

				<h3>Buffer</h3>
				<p>
					buffer是一个数组，它通过几个变量来保存数据写入状态：<br>
					1.capacity：容量，缓冲区能容纳元素的数量<br>
					2.position：当前位置，是缓冲区中下一次发生读取和写入操作的索引，当前位置通过大多数读写操作向前推进<br>
					3.limit：界限，是缓冲区中最后一个有效位置之后下一个位置的索引<br>
					如图：
    			</p>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_005.png" alt="" />
                </div>
                <p>buff是这样操作的：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_006.png" alt="" />
                </div>

				<h3>Channel</h3>
				<p>
					共有四种通道：<br>
					FileChannel：作用于IO文件流<br>
					DatagramChannel：作用于UDP协议<br>
					SocketChannel：作用于TCP协议<br>
					ServerSocketChannel：作用于TCP协议<br>
    			</p>
    			<p>打开一个ServerSocketChannel通道</p>
    			<blockquote>
				<p>
					ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
				</p>
				</blockquote>
				<p>关闭ServerSocketChannel通道</p>
    			<blockquote>
				<p>
					serverSocketChannel.close();
				</p>
				</blockquote>
				<p>循环监听SocketChannel：</p>
    			<blockquote>
				<p>
					while(true){
					    SocketChannel socketChannel = serverSocketChannel.accept();<br>
					    clientChannel.configureBlocking(false);	//设置为非阻塞
					}
				</p>
				</blockquote>

				<h3>多路复用器 Selector</h3>
				<p>
					Selector是channel的管理者：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。所以服务端通常会死循环执行select()方法，直到有channl准备就绪，然后开始工作每个channel都会和Selector绑定一个事件，然后生成一个SelectionKey的对象<br>
					在NIO中一共有四种事件：<br>
					1.SelectionKey.OP_CONNECT：连接事件<br>
					2.SelectionKey.OP_ACCEPT：接收事件<br>
					3.SelectionKey.OP_READ：读事件<br>
					4.SelectionKey.OP_WRITE：写事件<br>
    			</p>

                <blockquote>
				<p>
					1).数据从Buffer到Channel：channel.write(byteBuffer);<br>
					2).数据从Buffer到Server：byteBuffer.get(...);
				</p>
				</blockquote>

				
				<p>接下来，你可以试下同时打开一千个客户端，只要你的CPU够给力，服务端就不可能因为阻塞而降低性能</p>
				
               
                


				
                

              
                
                

               



							</section>
					</div>



				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>