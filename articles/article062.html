<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 15, 2018</span>
									<h1>java nio</h1>
								</header>


				<h3>传统的BIO编程：</h3>
                <p>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 可以看到，一个客户端对应于服务端一个独立线程。</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_001.png" alt="" />
                </div>

                <p>用代码演示下，1. 写一个简单的服务器（用到了线程池的技术来创建线程）：</p>
				<pre>
                  <code>
public class MyServer {
	private static ExecutorService executorService = Executors.newCachedThreadPool(); // 创建一个线程池

	private static class HandleMsg implements Runnable { // 一旦有新的客户端请求，创建这个线程进行处理
		Socket client; // 创建一个客户端

		public HandleMsg(Socket client) { // 构造传参绑定
			this.client = client;
		}

		@Override
		public void run() {
			BufferedReader bufferedReader = null; // 创建字符缓存输入流
			PrintWriter printWriter = null; // 创建字符写入流
			try {
				bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream())); // 获取客户端的输入流
				printWriter = new PrintWriter(client.getOutputStream(), true); // 获取客户端的输出流，true是随时刷新
				String inputLine = null;
				long a = System.currentTimeMillis();
				while ((inputLine = bufferedReader.readLine()) != null) {
					printWriter.println(inputLine);
				}
				long b = System.currentTimeMillis();
				System.out.println("此线程花费了：" + (b - a) + "秒！");
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				try {
					bufferedReader.close();
					printWriter.close();
					client.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public static void main(String[] args) throws IOException { // 服务端的主线程是用来循环监听客户端请求
		ServerSocket server = new ServerSocket(8686); // 创建一个服务端且端口为8686
		Socket client = null;
		while (true) { // 循环监听
			client = server.accept(); // 服务端监听到一个客户端请求
			System.out.println(client.getRemoteSocketAddress() + "地址的客户端连接成功!");
			executorService.submit(new HandleMsg(client)); // 将该客户端请求通过线程池放入HandlMsg线程中进行处理
		}
	}

}
                  </code>
                </pre>
                <p>2. 写一个简单客户端：</p>
				<pre>
                  <code>
public class MyClient {
	
	public static void main(String[] args) throws IOException {
		Socket client = null;
		PrintWriter printWriter = null;
		BufferedReader bufferedReader = null;
		try {
			client = new Socket();
			client.connect(new InetSocketAddress("localhost", 8686));
			printWriter = new PrintWriter(client.getOutputStream(), true);
			printWriter.println("hello");
			printWriter.flush();

			bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream())); // 读取服务器返回的信息并进行输出
			System.out.println("来自服务器的信息是：" + bufferedReader.readLine());
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			printWriter.close();
			bufferedReader.close();
			client.close();
		}
	}
}
                  </code>
                </pre>

                <p>3. 代码运行结果如下图</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_002.png" alt="" />
                </div>
				<p>
					如果一个客户端请求中，IO写入到服务端过程中耗时10秒，即每个请求占用服务端线程10秒<br>
					然后有大量的客户端请求，每个请求都占用那么长时间，那么服务端的并能能力就会大幅度下降<br>
					这并不是因为服务端有多少繁重的任务，而仅仅是因为服务线程在等待IO（因为accept，read，write都是阻塞式的）<br>
					让高速运行的CPU去等待及其低效的网络IO是非常不合算的行为<br><br>
				</p>


				<h3>NIO编程：</h3>
                <p>
					NIO成功的解决了上述问题，它是怎样解决的呢？<br>
					IO处理客户端请求的最小单位是线程，而NIO使用了比线程还小一级的单位：通道（Channel）<br>
					一个Channel可以理解为一个客户端输入/输出通道，每个Channel在一个Selector上注册，Selector会轮询每个Channel，当Channel有数据输入/输出，将Channel select出来，并用SelectionKey唯一标识Channel<br>
					因此，NIO中只需要一个线程就能完成所有接收，读，写等操作<br>

					要学习NIO，首先要理解它的三大核心设计：<br>
				</p>
				<blockquote>
				<p>
					Buffer，缓冲区<br>
					Channel，通道<br>
					Selector，选择器<br>
				</p>
				</blockquote>

				<p>类关系图：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_003.png" alt="" />
                </div>
                <p>TCP下的NIO工作流程图：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_004.png" alt="" />
                </div>

				<h3>Buffer</h3>
				<p>
					buffer是一个数组，它通过几个变量来保存数据写入状态：<br>
					1.capacity：指的是缓冲区的容量；<br>
					2.position：指的是下一个要被读写的元素的数组下标索引，该值会随get()和put()的调用自动更新；<br>
					3.limit：指的是缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量；<br>
					如图：
    			</p>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_005.png" alt="" />
                </div>
                <p>buffer是这样操作的：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_006.png" alt="" />
                </div>
                <p>1、创建一个容量大小为10的字符缓冲区</p>
                <pre>
                  <code>
ByteBuffer buff = ByteBuffer.allocate(10);
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_007.png" alt="" />
                </div>
                <p>2、往缓冲区中put()五个字节</p>
                <pre>
                  <code>
buff.put((byte)'H').put((byte)'e').put((byte)'l').put((byte)'l').put((byte)'0');
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_008.png" alt="" />
                </div>
                <p>3、调用flip()方法，切换为读就绪状态</p>
                <pre>
                  <code>
buff.flip();
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_009.png" alt="" />
                </div>
                <p>4、读取两个元素</p>
                <pre>
                  <code>
System.out.println("" + (char) buff.get() + (char) buff.get());
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_010.png" alt="" />
                </div>
                <p>5、标记此时的position位置</p>
                <pre>
                  <code>
buff.mark();
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_011.png" alt="" />
                </div>
                <p>6、调用compact()方法，释放已读数据的空间，准备重新填充缓存区</p>
                <pre>
                  <code>
buff.compact();
                  </code>
                </pre>
    			<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_012.png" alt="" />
                </div>


				<h3>Channel</h3>
				<p>
					共有四种通道：<br>
					FileChannel：作用于IO文件流<br>
					DatagramChannel：作用于UDP协议<br>
					SocketChannel：作用于TCP协议<br>
					ServerSocketChannel：作用于TCP协议<br>
    			</p>
    			<p>打开一个ServerSocketChannel通道</p>
    			<blockquote>
				<p>
					ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
				</p>
				</blockquote>
				<p>关闭ServerSocketChannel通道</p>
    			<blockquote>
				<p>
					serverSocketChannel.close();
				</p>
				</blockquote>
				<p>循环监听SocketChannel：</p>
    			<blockquote>
				<p>
					while(true){
					    SocketChannel socketChannel = serverSocketChannel.accept();<br>
					    clientChannel.configureBlocking(false);	//设置为非阻塞
					}
				</p>
				</blockquote>

				<h3>多路复用器 Selector</h3>
				<p>
					Selector是channel的管理者：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。所以服务端通常会死循环执行select()方法，直到有channl准备就绪，然后开始工作每个channel都会和Selector绑定一个事件，然后生成一个SelectionKey的对象<br>
					在NIO中一共有四种事件：<br>
					1.SelectionKey.OP_CONNECT：连接事件<br>
					2.SelectionKey.OP_ACCEPT：接收事件<br>
					3.SelectionKey.OP_READ：读事件<br>
					4.SelectionKey.OP_WRITE：写事件<br><br>
    			</p>

    			<p>1. 写一个NIO处理输入输出的服务端：</p>
				<pre>
                  <code>
package com.linfengda.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class MyNioServer {
	private Selector selector; // 创建一个选择器
	private final static int port = 8686;
	private final static int BUF_SIZE = 10240;

	private void initServer() throws IOException {
		
		// 创建通道管理器对象selector
		this.selector = Selector.open();
		
		// 创建一个通道对象channel
		ServerSocketChannel channel = ServerSocketChannel.open();
		channel.configureBlocking(false); // 将通道设置为非阻塞
		channel.socket().bind(new InetSocketAddress(port)); // 将通道绑定在8686端口

		// 将通道管理器和通道绑定，并为该通道注册OP_ACCEPT事件
		// 注册事件后，当该事件到达时，selector.select()会返回（一个key），如果该事件没到达selector.select()会一直阻塞
		SelectionKey selectionKey = channel.register(selector, SelectionKey.OP_ACCEPT);

		while (true) { // 轮询
			selector.select(); // 这是一个阻塞方法，一直等待直到有数据可读，返回值是key的数量（可以有多个）
			Set keys = selector.selectedKeys(); // 如果channel有数据了，将生成的key访入keys集合中
			Iterator iterator = keys.iterator();
			while (iterator.hasNext()) {
				SelectionKey key = (SelectionKey) iterator.next();
				iterator.remove(); // 拿到当前key实例之后记得在迭代器中将这个元素删除，非常重要，否则会出错
				if (key.isAcceptable()) { // 判断当前key所代表的channel是否在Acceptable状态，如果是就进行接收
					doAccept(key);
				} else if (key.isReadable()) {
					doRead(key);
				} else if (key.isWritable() &amp;&amp; key.isValid()) {
					doWrite(key);
				} else if (key.isConnectable()) {
					System.out.println("连接成功！");
				}
			}
		}
	}

	public void doAccept(SelectionKey key) throws IOException {
		ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
		System.out.println("ServerSocketChannel正在循环监听");
		SocketChannel clientChannel = serverChannel.accept();
		clientChannel.configureBlocking(false);
		clientChannel.register(key.selector(), SelectionKey.OP_READ);
	}

	public void doRead(SelectionKey key) throws IOException {
		SocketChannel clientChannel = (SocketChannel) key.channel();
		ByteBuffer byteBuffer = ByteBuffer.allocate(BUF_SIZE);
		long bytesRead;
		while ((bytesRead = clientChannel.read(byteBuffer)) > 0) {
			byteBuffer.flip();
			byte[] data = byteBuffer.array();
			String info = new String(data).trim();
			System.out.println("从客户端发送过来的消息是：" + info);
			byteBuffer.clear();
		}
		if (bytesRead == -1) {
			clientChannel.close();
		}
	}

	public void doWrite(SelectionKey key) throws IOException {
		ByteBuffer byteBuffer = ByteBuffer.allocate(BUF_SIZE);
		byteBuffer.flip();
		SocketChannel clientChannel = (SocketChannel) key.channel();
		while (byteBuffer.hasRemaining()) {
			clientChannel.write(byteBuffer);
		}
		byteBuffer.compact();
	}

	public static void main(String[] args) throws IOException {
		MyNioServer myNioServer = new MyNioServer();
		myNioServer.initServer();
	}
}
                  </code>
                </pre>
                <p>
                	我打印了监听channel，告诉大家ServerSocketChannel是在什么时候开始运行的<br>
					如果配合NIO客户端的debug，就能很清楚的发现，进入select()轮询前，虽然已经有了ACCEPT事件的KEY，但select()默认并不会去调用，而是要等待有其它感兴趣事件被select()捕获之后，才会去调用ACCEPT的SelectionKey，这时候ServerSocketChannel才开始进行循环监听<br>
					也就是说一个Selector中，始终保持着ServerSocketChannel的运行，而serverChannel.accept();真正做到了异步（在initServer方法中的channel.configureBlocking(false);），如果没有接受到connect，会返回一个null，如果成功连接了一个SocketChannel，则此SocketChannel会注册写入（READ）事件，并且设置为异步<br>
                </p>

                <p>2. 写一个NIO处理输入输出的客户端：</p>
				<pre>
                  <code>
package com.linfengda.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

public class MyNioClient {
	private Selector selector; // 创建一个选择器
	private final static int port = 8686;
	private final static int BUF_SIZE = 10240;
	private static ByteBuffer byteBuffer = ByteBuffer.allocate(BUF_SIZE);

	private void initClient() throws IOException {
		this.selector = Selector.open();
		SocketChannel clientChannel = SocketChannel.open();
		clientChannel.configureBlocking(false);
		clientChannel.connect(new InetSocketAddress(port));
		clientChannel.register(selector, SelectionKey.OP_CONNECT);
		while (true) {
			selector.select();
			Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
			while (iterator.hasNext()) {
				SelectionKey key = iterator.next();
				iterator.remove();
				if (key.isConnectable()) {
					doConnect(key);
				} else if (key.isReadable()) {
					doRead(key);
				}
			}
		}
	}

	public void doConnect(SelectionKey key) throws IOException {
		SocketChannel clientChannel = (SocketChannel) key.channel();
		if (clientChannel.isConnectionPending()) {
			clientChannel.finishConnect();
		}
		clientChannel.configureBlocking(false);
		String info = "服务端你好!!";
		byteBuffer.clear();
		byteBuffer.put(info.getBytes("UTF-8"));
		byteBuffer.flip();
		clientChannel.write(byteBuffer);
		// clientChannel.register(key.selector(),SelectionKey.OP_READ);
		clientChannel.close();
	}

	public void doRead(SelectionKey key) throws IOException {
		SocketChannel clientChannel = (SocketChannel) key.channel();
		clientChannel.read(byteBuffer);
		byte[] data = byteBuffer.array();
		String msg = new String(data).trim();
		System.out.println("服务端发送消息：" + msg);
		clientChannel.close();
		key.selector().close();
	}

	public static void main(String[] args) throws IOException {
		MyNioClient myNioClient = new MyNioClient();
		myNioClient.initClient();
	}
}
                  </code>
                </pre>

                <p>3. 代码运行结果如下图（这里我打开一个服务端，两个客户端）：</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article062_013.png" alt="" />
                </div>
				<p>接下来，你可以试下同时打开一千个客户端，只要你的CPU够给力，服务端就不可能因为阻塞而降低性能。</p>
				
               
                

							</section>
					</div>



				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>