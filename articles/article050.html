<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 21, 2018</span>
									<h1>java lock</h1>
									<p>
Java锁详解
								    </p>
								</header>

                <h3>Java提供了多种多线程锁机制的实现方式，常见的有：</h3>
                <blockquote>
                <p>
synchronized<br>
ReentrantLock<br>
Semaphore<br>
AtomicInteger等
                </p>
                </blockquote>

                <h3>synchronized</h3>
                <p>synchronized实现的机理依赖于软件层面上的JVM，因此其性能会随着Java版本的不断升级而提高。到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。 </p>
                
                <h3>ReentrantLock</h3>
                <p>ReentrantLock实现的机理依赖于特殊的CPU指定，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。因此我们建议在高并发量情况下使用ReentrantLock。 </p>
                <h4>ReentrantLock的非公平锁</h4>
                <pre>
                  <code>
final boolean nonfairTryAcquire(int acquires) {
            //获取当前线程
            final Thread current = Thread.currentThread();
            //通过AQS获取同步状态
            int c = getState();
            //同步状态为0，说明临界区处于无锁状态，
            if (c == 0) {
                //修改同步状态，即加锁
                if (compareAndSetState(0, acquires)) {
                    //将当前线程设置为锁的owner
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //如果临界区处于锁定状态，且上次获取锁的线程为当前线程
            else if (current == getExclusiveOwnerThread()) {
                 //则递增同步状态
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
                  </code>
                </pre>
                <p>非公平锁是指当锁状态为可用时，不管在当前锁上是否有其他线程在等待，新近线程都有机会抢占锁。上述代码即为非公平锁和核心实现，可以看到只要同步状态为0，任何调用lock的线程都有可能获取到锁，而不是按照锁请求的FIFO原则来进行的。</p>    
                <h4>ReentrantLock的公平锁</h4>
                <pre>
                  <code>
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //此处为公平锁的核心，即判断同步队列中当前节点是否有前驱节点
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
                  </code>
                </pre>
                <p>从上面的代码中可以看出，公平锁与非公平锁的区别仅在于是否判断当前节点是否存在前驱节点!hasQueuedPredecessors()，由AQS可知，如果当前线程获取锁失败就会被加入到AQS同步队列中，那么，如果同步队列中的节点存在前驱节点，也就表明存在线程比当前节点线程更早的获取锁，故只有等待前面的线程释放锁后才能获取锁。</p>

                <h3>CAS</h3>
                <blockquote>
                <p>
1.ABA问题<br>
2.自旋时间过长<br>
3.只能保证一个共享变量的原子操作
                </p>
                </blockquote>

                <h3>AQS</h3>
                <p>同步队列是AQS很重要的组成部分，它是一个双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会被构造成一个Node节点假如到同步队列的</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article050_001.png" alt="" />
                </div>

                <h3>乐观锁</h3>
                <p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的。</p>

				<h3>悲观锁</h3>
                <p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>

                <h3>锁的状态</h3>
                <blockquote>
                <p>
1.无锁状态
2.偏向锁状态
3.轻量级锁状态
4.重量级锁状态
                </p>
                </blockquote>
                <p>要注意的是，这四种状态都不是Java语言中的锁，而是使用synchronized时，Jvm为了提高锁的获取与释放效率而做的优化。</p>
                <h3>偏向锁</h3>
                <blockquote>
                <p>
1.测试对象头Mark Word(默认存储对象的HashCode,分代年龄，锁标记位)里是否存储着指向当前线程的偏向锁
2.若测试失败，则测试Mark Word中偏向锁标识是否设置成1(表示当前为偏向锁)
3.没有设置则使用CAS竞争，否则尝试使用CAS将对象头的偏向锁指向当前线程
                </p>
                </blockquote>
                <h3>轻量级锁</h3>
                <blockquote>
                <p>
1.当有第二个线程进入同步代码块时，偏向锁会升级为轻量级锁
2.如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁
                </p>
                </blockquote>
                <h3>重量级锁</h3>
                <blockquote>
                <p>
1.当有另一个线程与该线程同时竞争时，轻量级锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级
2.其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，进行竞争
                </p>
                </blockquote>
                <h3>三种锁的对比</h3>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article050_002.png" alt="" />
                </div>



                <pre>
                  <code>
-Xmx4096m //最大内存分配
-Xms4096m //最小内存分配
-Xss256k //每个线程的堆栈大小
//-XX:NewRatio=2 年轻代和老年代大小的比例，默认是2 G1垃圾回收最好不要设置采用下面的配置
-XX:G1NewSizePercent=30 //新生代最小值，默认值5%
-XX:G1MaxNewSizePercent=45 //新生代最大值，默认值60%
-XX:MetaspaceSize=256m //jdk8 元空间大小（相当于以前的perm）
-XX:MaxMetaspaceSize=512m //jdk8最大元空间大小
-XX:+UseG1GC //指定G1垃圾收集器
-XX:G1HeapRegionSize=16m //G1垃圾收集器分区大小
-XX:G1ReservePercent=25 //预留多少内存，防止晋升失败的情况，默认值是10
-XX:MaxTenuringThreshold=15 //晋升的阈值，默认是15（一个存活对象经历多少次GC周期之后晋升到老年代)
-XX:SurvivorRatio=8 //	eden和survivor区域空间大小的比例，默认是8
-XX:+ParallelRefProcEnabled //采用多线程的方式发现需要处理的finalize方法的对象，非多线程执行对象的finalize方法
-XX:-OmitStackTraceInFastThrow //一些频繁抛出的异常，JVM为了性能优化而抛出没有堆栈的异常，默认开启，
-XX:+AlwaysPreTouch //jvm预先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM
-XX:+PrintTenuringDistribution //显示出survivor区间有效对象的年龄(经历过几次新生代回收)分布情况，可以通过该参数的输出确定出survivor大小以及 MaxTenuringThreshold 的值
-XX:+PrintGCApplicationStoppedTime //打印垃圾收集期间应用被暂停的时间
-XX:+UnlockExperimentalVMOptions //打印出实验性的参数
-XX:InitiatingHeapOccupancyPercent=40 //内存占用达到整个堆百分之多少的时候开启一个GC周期，G1 GC会根据整个堆的占用，而不是某个代的占用情况去触发一个并发GC周期，0表示一直在GC，默认值是45
-XX:MaxGCPauseMillis=20 //G1收集器GC最大停顿时间ms
-XX:ParallelGCThreads=4 //GC在并行处理阶段启动多少个线程，默认值和平台有关。一般不设采用默认配置
-XX:ConcGCThreads=n //并发收集的时候使用多少个线程，默认值和平台有关。一般不设采用默认配置
-verbose:gc // 表示输出虚拟机中GC的详细情况
-XX:+PrintGCDetails //打印gc日志，打印的出日志包含日志收集原因，各区域变化情况，以及用时
-XX:+PrintHeapAtGC //打印gc前后堆详细信息，不管是minor gc还是full gc都会打印
-XX:+PrintGCDateStamps //日志中输出时间戳
-XX:+PrintPromotionFailure //是多大的新生代对象晋升到老生代失败从而引发Full GC
-XX:+HeapDumpOnOutOfMemoryError //在Out Of Memory，JVM快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误
-XX:+PrintAdaptiveSizePolicy //可以打印出survivor的一些详细信息，关于survivor区间是否溢出，是否有对象转移到老年代
-XX:+UseGCLogFileRotation //
-XX:NumberOfGCLogFiles=5 //
-XX:GCLogFileSize=30M //这三个参数用于设置gc文件滚动和设置滚动日志文件的个数，为了防止单个gc日志文件太大，生产上建议加上这两个参数；
-Xloggc:/opt/logs/jetty/gc_%p.log //gc log输出地址
-XX:HeapDumpPath=/opt/logs/jetty/java.hprof //heap dump日志地址
-XX:ErrorFile=/opt/logs/jetty/hs_err_pid%p.log //JVM crash时生成crash文件的路径
                  </code>
                </pre>

                
                





							</section>
					</div>





				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>
