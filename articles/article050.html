<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 21, 2018</span>
									<h1>java lock</h1>
									<p>
Java锁详解
								    </p>
								</header>

                <h3>Java提供了多种多线程锁机制的实现方式，常见的有：</h3>
                <blockquote>
                <p>
synchronized<br>
ReentrantLock<br>
Semaphore<br>
AtomicInteger等
                </p>
                </blockquote>

                <h3>synchronized</h3>
                <p>synchronized实现的机理依赖于软件层面上的JVM，因此其性能会随着Java版本的不断升级而提高。到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。 </p>
                
                <h3>ReentrantLock</h3>
                <p>ReentrantLock实现的机理依赖于特殊的CPU指定，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。因此我们建议在高并发量情况下使用ReentrantLock。 </p>
                <h4>ReentrantLock的非公平锁</h4>
                <pre>
                  <code>
final boolean nonfairTryAcquire(int acquires) {
            //获取当前线程
            final Thread current = Thread.currentThread();
            //通过AQS获取同步状态
            int c = getState();
            //同步状态为0，说明临界区处于无锁状态，
            if (c == 0) {
                //修改同步状态，即加锁
                if (compareAndSetState(0, acquires)) {
                    //将当前线程设置为锁的owner
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //如果临界区处于锁定状态，且上次获取锁的线程为当前线程
            else if (current == getExclusiveOwnerThread()) {
                 //则递增同步状态
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
                  </code>
                </pre>
                <p>非公平锁是指当锁状态为可用时，不管在当前锁上是否有其他线程在等待，新近线程都有机会抢占锁。上述代码即为非公平锁和核心实现，可以看到只要同步状态为0，任何调用lock的线程都有可能获取到锁，而不是按照锁请求的FIFO原则来进行的。</p>    
                <h4>ReentrantLock的公平锁</h4>
                <pre>
                  <code>
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //此处为公平锁的核心，即判断同步队列中当前节点是否有前驱节点
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
                  </code>
                </pre>
                <p>从上面的代码中可以看出，公平锁与非公平锁的区别仅在于是否判断当前节点是否存在前驱节点!hasQueuedPredecessors()，由AQS可知，如果当前线程获取锁失败就会被加入到AQS同步队列中，那么，如果同步队列中的节点存在前驱节点，也就表明存在线程比当前节点线程更早的获取锁，故只有等待前面的线程释放锁后才能获取锁。</p>

                <h3>CAS</h3>
                <blockquote>
                <p>
1.ABA问题<br>
2.自旋时间过长<br>
3.只能保证一个共享变量的原子操作
                </p>
                </blockquote>

                <h3>AQS</h3>
                <p>同步队列是AQS很重要的组成部分，它是一个双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果锁已经被占用，那么当前线程会被构造成一个Node节点加入到同步队列</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article050_001.png" alt="" />
                </div>

                <h3>乐观锁</h3>
                <p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的。</p>

				<h3>悲观锁</h3>
                <p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>

                <h3>锁的状态</h3>
                <blockquote>
                <p>
1.无锁状态
2.偏向锁状态
3.轻量级锁状态
4.重量级锁状态
                </p>
                </blockquote>
                <p>要注意的是，这四种状态都不是Java语言中的锁，而是使用synchronized时，Jvm为了提高锁的获取与释放效率而做的优化。</p>
                <h3>偏向锁</h3>
                <blockquote>
                <p>
1.当线程请求到锁对象后，将锁对象的状态标志位改为1，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中<br>
2.后续该线程可以直接进入同步块，连CAS操作都不需要
                </p>
                </blockquote>
                <h3>轻量级锁</h3>
                <blockquote>
                <p>
1.当有第二个线程进入同步代码块时，偏向锁会升级为轻量级锁<br>
2.使用CAS操作将锁对象的Mark Word指向该锁记录，不使用互斥同步，这样能减少互斥同步所使用的『互斥量』带来的性能开销
                </p>
                </blockquote>
                <h3>重量级锁</h3>
                <blockquote>
                <p>
1.当有另一个线程与该线程同时竞争时，轻量级锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级
2.其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，进行竞争
                </p>
                </blockquote>
                <h3>三种锁的对比</h3>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article050_002.png" alt="" />
                </div>



                
                





							</section>
					</div>





				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>
