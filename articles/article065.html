<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 21, 2018</span>
									<h1>spring boot chapter2</h1>
									<p>
                                    How to build a efficient spring boot project. 
								    </p>
								</header>



                <h3>1. 怎么在spring boot中集成redis？</h3>
                <p>
一个响应快速的系统，必然要在请求资源服务接口中避免所有能避免的DB操作，这时候redis是一个相当不错的选择。它稳定，高效，简便，还支持分布式扩展。
                </p>
                <p>(1)先在application.yml中配置本地单机redis，这里有一个坑，就是在Spring Boot 1.2及更高的版本中,spring.redis.pool.max-active等属性已经过期，只能使用spring.redis.jedis.pool.max-active来代替。关于spring redis的默认配置，可以参考org.springframework.boot.autoconfigure.data.redisRedisProperties类。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_001.png" alt="" />
                </div>
                <p>(2)然后我们指定下redisTemplate类的序列化方式为Jackson2JsonRedisSerializer，如果不指定默认使用JdkSerializationRedisSerializer。这里说下，spring data提供了2种json序列化器，GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializer，它们的序列化方式一样（调用的代码一样），即在序列化时将java类型和javaBean的json格式一起写入byte数组。然后在反序列化时，根据java类型将字节数组反序列化为对应类型的javaBean。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_002.png" alt="" />
                </div>
                <p>不同之处在于：GenericJackson2JsonRedisSerializer在反序列化时多了个参数java类型，可以根据传入的java类型反序列化。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_003.png" alt="" />
                </div>
                <p>我们配置下redis的序列化方式，然后测试下Jackson2JsonRedisSerializer能序列化的java类型。</p>
                <pre>
                  <code>
/**
 * 描述: Redis配置
 *
 * @author linfengda
 * @create 2018-09-10 17:00
 */
@SpringBootConfiguration
public class RedisConfig {

    /**
     * 如果不配置这个bean，会默认初始化一个使用JdkSerializationRedisSerializer的redisTemplate实例。
     * @param connectionFactory
     * @return
     */
    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);

        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // 配置序列化和反序列化方式
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }

}
                  </code>
                </pre>
                <p>(3)Jackson2JsonRedisSerializer对java类型的兼容性测试，测试它对每种java类型的序列化和反序列化是否会有问题。</p>
                <pre>
                  <code>
/**
 * 描述: 序列化的类型测试
 *
 * @author linfengda
 * @create 2018-09-12 15:54
 */
@Data
public class MySon extends YourPapa {

    private int f1;
    private long f2;
    private float f3;
    private double f4;
    private char f5;
    private boolean f6;
    private String f7;
    private Timestamp f8;
    private int[] f9;
    private long[] f10;
    private float[] f11;
    private double[] f12;
    private char[] f13;
    private boolean[] f14;
    private String[] f15;
    private Pig pig;
    private List&lt;Pig&gt; childPigs;
    private Map&lt;String, Pig&gt; kindPigs;

}
                  </code>
                </pre>
                <pre>
                  <code>
/**
 * 描述: 这是一只猪
 *
 * @author linfengda
 * @create 2018-09-12 16:08
 */
@Data
public class Pig {

    private long id;
    private String code;
    private String master;
    private double weight;
    private int growDays;
}
                  </code>
                </pre>
                <p>(4)使用Chapter1ApplicationTestslei类测试下redisTemplate的使用，这里我们需要先把/main/resources目录下的配置文件复制到/test/resources，否则会报找不到配置文件错误。然后我们使用上面的java类进行测试。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_004.png" alt="" />
                </div>
                <p>(5)Redis Desktop Manager查看信息如下，可以看到头部带有java类型信息。可以看到我们使用了几乎所有常用的数据类型，包括：
                列表，哈希表，继承，自定义类型，</br>
                都能序列化和反序列化成功，并且没有信息丢失。</br>
                支持度比Protobuff好，Protobuff对某些类型字段，例如javas.ql.TimeStamp序列化和反序列化后，会变成格林威治时间，即1970-1-1 00:00:00,但是有一点，Protobuff对整形的处理速度是Jackson的3倍，对浮点型的处理速度是Jackson的13倍。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_005.png" alt="" />
                </div>
                <p>(6)接下来我们测试下Jackson2JsonRedisSerializer序列化器对redis数据类型： List, Set, Zset的支持。</p>
                <h3>List类型操作</h3>
                <p>redis list是使用双向链表实现的，对redis list的操作更像对队列的操作，除了LINDEX，LSET，LINSERT命令外，其它命令的时间复杂度都为O(1)。</p>
                <pre>
                  <code>
private void ListSerializeTest() {
        Pig peggy = new Pig();
        peggy.setId(1);
        peggy.setCode(&quot;peggy&quot;);
        peggy.setMaster(&quot;Jack&quot;);
        peggy.setWeight(100);
        peggy.setGrowDays(100);

        Pig george = new Pig();
        george.setId(2);
        george.setCode(&quot;george&quot;);
        george.setMaster(&quot;Jack&quot;);
        george.setWeight(150);
        george.setGrowDays(150);

        Pig tom = new Pig();
        tom.setId(2);
        tom.setCode(&quot;tom&quot;);
        tom.setMaster(&quot;Jack&quot;);
        tom.setWeight(120);
        tom.setGrowDays(120);

        Pig wilson = new Pig();
        wilson.setId(2);
        wilson.setCode(&quot;wilson&quot;);
        wilson.setMaster(&quot;Jack&quot;);
        wilson.setWeight(110);
        wilson.setGrowDays(110);

        List&lt;Pig&gt; pigList = new ArrayList&lt;&gt;();
        pigList.add(tom);
        pigList.add(wilson);

        log.info(&quot;===================================redis list序列化&quot;);
        ListOperations&lt;String, Object&gt; listOperations = simpleRedisTemplate.opsForList();
        listOperations.rightPushAll(&quot;pigList&quot;, peggy, george);
        listOperations.rightPushAll(&quot;pigList&quot;, pigList.toArray());
        // 由于org.springframework.data.redis.core.ListOperations的2个重载方法破坏了里氏替换原则，
        // 对rightPushAll(K key, Collection&lt;V&gt; values)方法的调用会变成对rightPushAll(K key, V... values)方法的调用
        //listOperations.rightPushAll(&quot;pigList&quot;, pigList);

        log.info(&quot;===================================redis list反序列化&quot;);

        // 左边元素出队列（出队列后该值在列表中将不存在）
        log.info(listOperations.leftPop(&quot;pigList&quot;).toString());
        log.info(listOperations.leftPop(&quot;pigList&quot;).toString());

        // 返回列表中指定位置的元素（不会移除列表中元素）
        List pigs = listOperations.range(&quot;pigList&quot;, 0, -1);
        for (Object pig : pigs) {
            log.info(pig.toString());
        }
    }
                  </code>
                </pre>
                <p>输出的反序列化信息如下：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_007.png" alt="" />
                </div>

                <h3>Set类型操作</h3>
                <p>redis set是使用整数集合或hashtable实现的，对于元素都是整形的集合，使用整数集合编码，对于字符串的集合。使用hashtable编码，
                除了SMEMBERS，SUNION/SUNIONSTORE，SINTER/SINTERSTORE，SDIFF/SDIFFSTORE命令外，其它命令的时间复杂度都为O(1)。</p>
                <pre>
                  <code>
    private void SetSerializeTest() {
        Pig peggy = new Pig();
        peggy.setId(1);
        peggy.setCode(&quot;peggy&quot;);
        peggy.setMaster(&quot;Jack&quot;);
        peggy.setWeight(100);
        peggy.setGrowDays(100);

        Pig george = new Pig();
        george.setId(2);
        george.setCode(&quot;george&quot;);
        george.setMaster(&quot;Jack&quot;);
        george.setWeight(150);
        george.setGrowDays(150);

        Pig tom = new Pig();
        tom.setId(3);
        tom.setCode(&quot;tom&quot;);
        tom.setMaster(&quot;Jack&quot;);
        tom.setWeight(120);
        tom.setGrowDays(120);

        Pig wilson = new Pig();
        wilson.setId(4);
        wilson.setCode(&quot;wilson&quot;);
        wilson.setMaster(&quot;Jack&quot;);
        wilson.setWeight(110);
        wilson.setGrowDays(110);

        log.info(&quot;===================================redis list序列化&quot;);
        SetOperations&lt;String, Object&gt; setOperations = simpleRedisTemplate.opsForSet();
        // 向集合中添加元素
        setOperations.add(&quot;pigFamily&quot;, peggy, george, tom, wilson);
        // 移除集合中一个或多个元素
        setOperations.remove(&quot;pigFamily&quot;, wilson);
        // 判断元素peggy是否是集的成员
        log.info(&quot;peggy is one of pigFamily: &quot; + setOperations.isMember(&quot;pigFamily&quot;, peggy));

        log.info(&quot;===================================redis list反序列化&quot;);
        // 返回集合中的所有元素
        Set pigs = setOperations.members(&quot;pigFamily&quot;);
        for (Object pig : pigs) {
            log.info(pig.toString());
        }
    }
                  </code>
                </pre>
                <p>输出的反序列化信息如下：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_008.png" alt="" />
                </div>

                <h3>Hash类型操作</h3>
                <p>redis hash是使用hashtable实现的，除了HGETALL，HKEYS/HVALS命令外，其它命令的时间复杂度都为O(1)。</p>
                <pre>
                  <code>
private void HashSerializeTest() {
        Pig peggy = new Pig();
        peggy.setId(1);
        peggy.setCode(&quot;peggy&quot;);
        peggy.setMaster(&quot;Jack&quot;);
        peggy.setWeight(100);
        peggy.setGrowDays(100);

        Pig george = new Pig();
        george.setId(2);
        george.setCode(&quot;george&quot;);
        george.setMaster(&quot;Jack&quot;);
        george.setWeight(150);
        george.setGrowDays(150);

        Pig tom = new Pig();
        tom.setId(3);
        tom.setCode(&quot;tom&quot;);
        tom.setMaster(&quot;Jack&quot;);
        tom.setWeight(120);
        tom.setGrowDays(120);

        Pig wilson = new Pig();
        wilson.setId(4);
        wilson.setCode(&quot;wilson&quot;);
        wilson.setMaster(&quot;Jack&quot;);
        wilson.setWeight(110);
        wilson.setGrowDays(110);

        log.info(&quot;===================================redis list序列化&quot;);
        HashOperations&lt;String, String, Object&gt; hashOperations = simpleRedisTemplate.opsForHash();
        // 向哈希表中添加元素
        hashOperations.put(&quot;pigFamily&quot;, &quot;peggy&quot;, peggy);
        hashOperations.put(&quot;pigFamily&quot;, &quot;george&quot;, george);
        hashOperations.put(&quot;pigFamily&quot;, &quot;tom&quot;, tom);
        hashOperations.put(&quot;pigFamily&quot;, &quot;wilson&quot;, wilson);
        // 移除哈希表中一个或多个元素
        hashOperations.delete(&quot;pigFamily&quot;, &quot;wilson&quot;);

        log.info(&quot;===================================redis list反序列化&quot;);
        // 获取哈希表中的元素
        Pig peggyPig = (Pig) hashOperations.get(&quot;pigFamily&quot;, &quot;peggy&quot;);
        log.info(peggyPig.toString());
        // 判断哈希表中是否存在元素peggy
        log.info(&quot;peggy is one of pigFamily: &quot; + hashOperations.hasKey(&quot;pigFamily&quot;, &quot;peggy&quot;));
    }
                  </code>
                </pre>
                <p>输出的反序列化信息如下：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_009.png" alt="" />
                </div>







				<h3>2. 尝试更加高效的序列化方式：protostuff</h3>



                <p>(6)接下来我们使用Protobuff实现序列化，ProtocolBuffers在谷歌被广泛用于各种结构化信息存储和交换。这里有个问题，就是ProtocolBuffer序列化时没有类型信息，因此在反序列化时需要传入java类型，然后通过反射的方式反序列化。所以在ProtoStuffSerializer序列化器的deserialize()方法里我们不做任何处理，返回到com.linfengda.sb.support.middleware.redis.SimpleRedisTemplate处理。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_006.png" alt="" />
                </div>
                <p>(7)有些同学喜欢再封装下redisTemplate，我觉得完全没必要，直接使用就很好用。如果需要做封装，可以使用继承的方式处理。在com.linfengda.sb.support.middleware.redis包下实现SimpleRedisTemplate类，继承RedisTemplate类，既可以保证对RedisTemplate任意方法的调用，又可以在我们需要统一的地方统一处理。</p>
                <pre>
                  <code>
/**
 * 描述: 对redis操作做统一处理：类型转换，业务默认超时时间等
 *
 * @author linfengda
 * @create 2018-09-12 13:40
 */
@Slf4j
public class SimpleRedisTemplate extends RedisTemplate&lt;Object, Object&gt; {
    @Value(&quot;${spring.redis.serializer}&quot;)
    private String serializer;


    public void setObject(String key, Object value) {
        super.opsForValue().set(key, value);
    }

    public &lt;T&gt; T getObject(String key, Class&lt;T&gt; clazz) {
        if (RedisConfig.Serializer.protoStuff.name().equals(serializer)) {
            // 当使用ProtoStuff序列化器时，需要这样做。
            byte[] bytes = (byte[]) super.opsForValue().get(key);
            if (bytes == null) {
                return null;
            } else {
                return ProtoStuffUtil.deserialize(bytes, clazz);
            }
        } else {
            T object = (T) super.opsForValue().get(key);
            return object;
        }
    }
......
                  </code>
                </pre>

                <h3>3. protostuff的坑</h3>
                <p>(1)不能反序列化java.sql.TimeStamp，如Myson.class的f8字段：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_010.png" alt="" />
                </div>
                <p>反序列化之后变成了格林威治时间+x：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_011.png" alt="" />
                </div>

				<p>(2)通过protostuff序列化一个对象时是按照可序列化字段顺序把值序列化到字节码中，反序列化时也是按照当前对象可序列化字段顺序赋值。所以如果序列化后修改了字段名称，反序列化时会将旧字段的值赋值到新字段。例如序列化一个Myson.class的实例，然后修改MySecondson.class的f7字段为f77，反序列化之后f77被赋值为f7的值：</p>
				<div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_012.png" alt="" />
                </div>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_013.png" alt="" />
                </div>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_014.png" alt="" />
                </div>

				<p>(3)序列化后不能修改对应顺序字段的类型，否则会出现反序列失败报错。然后修改MySecondson.class的f7字段类型由String修改为Object</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_015.png" alt="" />
                </div>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_016.png" alt="" />
                </div>
				<p>为了避免以上问题，在使用protostuff序列化时，对已有的实体中添加字段放到最后去就可以了。</p>
				

                <h3>4. 模块化编程和解耦</h3>
                <p>我们在application.yml配置文件中，增加参数spring.redis.serializer来配置序列化方式，spring.redis.serializer:protoStuff，即使用protoStuff序列化器，这样就可以通过参数直接指定redis序列化方式，做到解耦。</p>
                <pre>
                  <code>
/**
 * 描述: Redis配置
 *
 * @author linfengda
 * @create 2018-09-10 17:00
 */
@SpringBootConfiguration
public class RedisConfig {
    @Value(&quot;${spring.redis.serializer}&quot;)
    private String serializer;

    /**
     * 序列化类型
     */
    public enum Serializer {
        protoStuff, jackson;
        public static Serializer getType(String serializer) {
            for (Serializer s : values()) {
                if (s.name().equals(serializer)) {
                    return s;
                }
            }
            return null;
        }
    }


    /**
     * 如果不配置这个bean，会默认初始化一个使用JdkSerializationRedisSerializer的redisTemplate实例。
     * @param connectionFactory
     * @return
     */
    @Bean
    public SimpleRedisTemplate simpleRedisTemplate(RedisConnectionFactory connectionFactory) {
        SimpleRedisTemplate simpleRedisTemplate = new SimpleRedisTemplate();
        simpleRedisTemplate.setConnectionFactory(connectionFactory);

        // 配置序列化和反序列化方式
        simpleRedisTemplate.setKeySerializer(new StringRedisSerializer());
        simpleRedisTemplate.setHashKeySerializer(new StringRedisSerializer());
        simpleRedisTemplate.setValueSerializer(getRedisSerializer());
        simpleRedisTemplate.setHashValueSerializer(getRedisSerializer());
        simpleRedisTemplate.afterPropertiesSet();
        return simpleRedisTemplate;
    }

    private RedisSerializer getRedisSerializer() {
        Serializer serializer = Serializer.getType(this.serializer);
        switch (serializer) {
            case protoStuff:
                ProtoStuffSerializer protoStuffSerializer = new ProtoStuffSerializer();
                return protoStuffSerializer;
            case jackson:
                Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
                ObjectMapper om = new ObjectMapper();
                om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
                om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
                jackson2JsonRedisSerializer.setObjectMapper(om);
                return jackson2JsonRedisSerializer;
            default:
                ProtoStuffSerializer defaultSerializer = new ProtoStuffSerializer();
                return defaultSerializer;
        }
    }
                  </code>
                </pre>

                <p>(9)然后我们最终的目的是实现通过参数配置redis序列化器，且序列化方式对SimpleRedisTemplate方法的调用者透明。各模块间的关系设计如下：</p>

                <p>代码设计到这里，SimpleRedisTemplate类已经实现了对redis各种类型的操作，同时与序列化方式解耦。</p>




 


							</section>
					</div>



				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>