<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>lingfenda's blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">Massively</a></li>
							<li class="active"><a href="../generic.html">Page guide</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">April 21, 2018</span>
									<h1>spring boot chapter2</h1>
									<p>
spring boot chapter2: How to build a efficient spring boot project. 
								    </p>
								</header>



                <h3>1. 怎么在spring boot中集成redis？</h3>
                <p>
一个响应快速的系统，必然要在请求资源服务接口中避免所有能避免的DB操作，这时候redis是一个相当不错的选择。它稳定，高效，简便，还支持分布式扩展。
                </p>
                <p>(1)先在application.yml中配置本地单机redis，这里有一个坑，就是在Spring Boot 1.2及更高的版本中,spring.redis.pool.max-active等属性已经过期，只能使用spring.redis.jedis.pool.max-active来代替。关于spring redis的默认配置，可以参考org.springframework.boot.autoconfigure.data.redisRedisProperties类。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_001.png" alt="" />
                </div>
                <p>(2)然后我们指定下redisTemplate类的序列化方式为Jackson2JsonRedisSerializer，如果不指定默认使用JdkSerializationRedisSerializer。这里说下，spring data提供了2种json序列化器，GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializer，它们的序列化方式一样（调用的代码一样），即在序列化时将java类型和javaBean的json格式一起写入byte数组。然后在反序列化时，根据java类型将字节数组反序列化为对应类型的javaBean。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_002.png" alt="" />
                </div>
                <p>不同之处在于：GenericJackson2JsonRedisSerializer在反序列化时多了个参数java类型，可以根据传入的java类型反序列化。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_003.png" alt="" />
                </div>
                <p>我们配置下redis的序列化方式，然后测试下Jackson2JsonRedisSerializer能序列化的java类型。</p>
                <pre>
                  <code>
/**
 * 描述: Redis配置
 *
 * @author linfengda
 * @create 2018-09-10 17:00
 */
@SpringBootConfiguration
public class RedisConfig {

    /**
     * 如果不配置这个bean，会默认初始化一个使用JdkSerializationRedisSerializer的redisTemplate实例。
     * @param connectionFactory
     * @return
     */
    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);

        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // 配置序列化和反序列化方式
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }

}
                  </code>
                </pre>
                <p>(3)Jackson2JsonRedisSerializer对java类型的兼容性测试，测试它对每种java类型的序列化和反序列化是否会有问题。</p>
                <pre>
                  <code>
/**
 * 描述: 序列化的类型测试
 *
 * @author linfengda
 * @create 2018-09-12 15:54
 */
@Data
public class MySon extends YourPapa {

    private int f1;
    private long f2;
    private float f3;
    private double f4;
    private char f5;
    private boolean f6;
    private String f7;
    private Timestamp f8;
    private int[] f9;
    private long[] f10;
    private float[] f11;
    private double[] f12;
    private char[] f13;
    private boolean[] f14;
    private String[] f15;
    private Pig pig;
    private List&lt;Pig&gt; childPigs;
    private Map&lt;String, Pig&gt; kindPigs;

}
                  </code>
                </pre>
                <pre>
                  <code>
/**
 * 描述: 这是一只猪
 *
 * @author linfengda
 * @create 2018-09-12 16:08
 */
@Data
public class Pig {

    private long id;
    private String code;
    private String master;
    private double weight;
    private int growDays;
}
                  </code>
                </pre>
                <p>(4)使用Chapter1ApplicationTestslei类测试下redisTemplate的使用，这里我们需要先把/main/resources目录下的配置文件复制到/test/resources，否则会报找不到配置文件错误。然后我们使用上面的java类进行测试。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_004.png" alt="" />
                </div>
                <p>(5)Redis Desktop Manager查看信息如下，可以看到头部带有java类型信息。可以看到我们使用了几乎所有常用的数据类型，包括列表，哈希表，继承，自定义类型，都能序列化和反序列化成功，并且没有信息丢失（这在Protobuff中做不到）。但是有一点，Protobuff对整形的处理速度是Jackson的3倍，对浮点型的处理速度是Jackson的13倍。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_005.png" alt="" />
                </div>

                <p>(6)接下来我们使用Protobuff实现序列化，ProtocolBuffers在谷歌被广泛用于各种结构化信息存储和交换。这里有个问题，就是ProtocolBuffer序列化时没有类型信息，因此在反序列化时需要传入java类型，然后通过反射的方式反序列化。所以在ProtoStuffSerializer序列化器的deserialize()方法里我们不做任何处理，返回到com.linfengda.sb.support.middleware.redis.SimpleRedisTemplate处理。</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_006.png" alt="" />
                </div>
                <p>(7)有些同学喜欢再封装下redisTemplate，我觉得完全没必要，直接使用就很好用。如果需要做封装，可以使用继承的方式处理。在com.linfengda.sb.support.middleware.redis包下实现SimpleRedisTemplate类，继承RedisTemplate类，既可以保证对RedisTemplate任意方法的调用，又可以在我们需要统一的地方统一处理。</p>
                <pre>
                  <code>
/**
 * 描述: 对redis操作做统一处理：类型转换，业务默认超时时间等
 *
 * @author linfengda
 * @create 2018-09-12 13:40
 */
@Slf4j
public class SimpleRedisTemplate extends RedisTemplate&lt;Object, Object&gt; {
    @Value(&quot;${spring.redis.serializer}&quot;)
    private String serializer;


    public void setObject(String key, Object value) {
        super.opsForValue().set(key, value);
    }

    public &lt;T&gt; T getObject(String key, Class&lt;T&gt; clazz) {
        if (RedisConfig.Serializer.protoStuff.name().equals(serializer)) {
            // 当使用ProtoStuff序列化器时，需要这样做。
            byte[] bytes = (byte[]) super.opsForValue().get(key);
            if (bytes == null) {
                return null;
            } else {
                return ProtoStuffUtil.deserialize(bytes, clazz);
            }
        } else {
            T object = (T) super.opsForValue().get(key);
            return object;
        }
    }
......
                  </code>
                </pre>
                <p>我们使用配置参数spring.redis.serializer来配置序列化方式，现在在application.yml里参数${spring.redis.serializer}是protoStuff，即使用protoStuff序列化器。</p>
                <pre>
                  <code>
/**
 * 描述: Redis配置
 *
 * @author linfengda
 * @create 2018-09-10 17:00
 */
@SpringBootConfiguration
public class RedisConfig {
    /**
     * 序列化类型
     */
    public enum Serializer {
        protoStuff, jackson;
    }
    @Value(&quot;${spring.redis.serializer}&quot;)
    private String serializer;


    /**
     * 如果不配置这个bean，会默认初始化一个使用JdkSerializationRedisSerializer的redisTemplate实例。
     * @param connectionFactory
     * @return
     */
    @Bean
    public SimpleRedisTemplate simpleRedisTemplate(RedisConnectionFactory connectionFactory) {
        System.out.println(serializer);
        SimpleRedisTemplate simpleRedisTemplate = new SimpleRedisTemplate();
        simpleRedisTemplate.setConnectionFactory(connectionFactory);

        // 配置序列化和反序列化方式
        simpleRedisTemplate.setKeySerializer(new StringRedisSerializer());
        simpleRedisTemplate.setHashKeySerializer(new StringRedisSerializer());
        if (Serializer.protoStuff.name().equals(serializer)) {

            ProtoStuffSerializer protoStuffSerializer = new ProtoStuffSerializer();
            simpleRedisTemplate.setValueSerializer(protoStuffSerializer);
            simpleRedisTemplate.setHashValueSerializer(protoStuffSerializer);
        } else {

            Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
            ObjectMapper om = new ObjectMapper();
            om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
            om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
            jackson2JsonRedisSerializer.setObjectMapper(om);
            simpleRedisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
            simpleRedisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        }
        simpleRedisTemplate.afterPropertiesSet();
        return simpleRedisTemplate;
    }
......
                  </code>
                </pre>
                <p>这样就可以通过参数直接指定redis序列化方式，做到解耦。</p>
                <p>(8)接下来我们测试下这2种序列化器对redis数据类型： List, Set, Zset的支持。</p>

                <h3>List列表类型操作</h3>
                <pre>
                  <code>
private void ListSerializeTest() {
        Pig peggy = new Pig();
        peggy.setId(1);
        peggy.setCode(&quot;peggy&quot;);
        peggy.setMaster(&quot;Jack&quot;);
        peggy.setWeight(100);
        peggy.setGrowDays(100);

        Pig george = new Pig();
        george.setId(2);
        george.setCode(&quot;george&quot;);
        george.setMaster(&quot;Jack&quot;);
        george.setWeight(150);
        george.setGrowDays(150);

        Pig tom = new Pig();
        tom.setId(2);
        tom.setCode(&quot;tom&quot;);
        tom.setMaster(&quot;Jack&quot;);
        tom.setWeight(120);
        tom.setGrowDays(120);

        Pig wilson = new Pig();
        wilson.setId(2);
        wilson.setCode(&quot;wilson&quot;);
        wilson.setMaster(&quot;Jack&quot;);
        wilson.setWeight(110);
        wilson.setGrowDays(110);

        List&lt;Pig&gt; pigList = new ArrayList&lt;&gt;();
        pigList.add(tom);
        pigList.add(wilson);

        log.info(&quot;===================================redis list序列化&quot;);
        ListOperations&lt;String, Object&gt; listOperations = simpleRedisTemplate.opsForList();
        listOperations.rightPushAll(&quot;pigList&quot;, peggy, george);
        listOperations.rightPushAll(&quot;pigList&quot;, pigList.toArray());
        // 由于org.springframework.data.redis.core.ListOperations的2个重载方法破坏了里氏替换原则，
        // 对rightPushAll(K key, Collection&lt;V&gt; values)方法的调用会变成对rightPushAll(K key, V... values)方法的调用
        //listOperations.rightPushAll(&quot;pigList&quot;, pigList);

        log.info(&quot;===================================redis list反序列化&quot;);

        // 左边元素出队列（出队列后该值在列表中将不存在）
        log.info(listOperations.leftPop(&quot;pigList&quot;).toString());
        log.info(listOperations.leftPop(&quot;pigList&quot;).toString());

        // 返回列表中指定位置的元素（不会移除列表中元素）
        List pigs = listOperations.range(&quot;pigList&quot;, 0, -1);
        for (Object pig : pigs) {
            log.info(pig.toString());
        }
    }
                  </code>
                </pre>
                <p>输出的反序列化信息如下：</p>
                <div class="full-div">
                    <img style="max-width: 100%;max-height: 100%;" src="../images/article065_007.png" alt="" />
                </div>







                <h3>2. 比较Jackson和Protobuff哪个更加高效？</h3>
                <p>(1)我们分别用10^n次序列化来测试Jackson和Protobuff这2中序列化方式的耗时。在下方的图表中，蓝色柱表示Jackson，红色柱表示Protobuff，横坐标表示被序列化的bean数量，纵坐标表示序列化耗时。</p>









                





                


							</section>
					</div>



				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Untitled</li><li>Design: <a href="https://github.com/linfengda">genius_lin</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>